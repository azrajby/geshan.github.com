<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Docker | Geshan's Blog]]></title>
  <link href="http://geshan.com.np/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://geshan.com.np/"/>
  <updated>2018-12-25T19:54:13+11:00</updated>
  <id>http://geshan.com.np/</id>
  <author>
    <name><![CDATA[Geshan Manandhar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[4 Ways Docker Changed the Way Software Engineers Work in Past Half Decade]]></title>
    <link href="http://geshan.com.np/blog/2018/12/4-ways-docker-changed-the-way-software-engineers-work-in-past-half-decade/"/>
    <updated>2018-12-01T09:14:51+11:00</updated>
    <id>http://geshan.com.np/blog/2018/12/4-ways-docker-changed-the-way-software-engineers-work-in-past-half-decade</id>
    <content type="html"><![CDATA[<p>10 years back it was Git that transformed the way software engineers worked. Half a decade back it was <a href="https://www.docker.com/">Docker</a> that brought the container to the masses. Before Docker, container was like a sacred secret in companies like Google and Heroku. Docker is a software and a company too. It tried to build a broader ecosystem but <a href="https://kubernetes.io/">Kubernetes</a> stole the thunder along the way keeping <a href="https://docs.docker.com/engine/swarm/">swarm</a> at bay. This post is not about how some Docker tools are not popular. It is about how Docker has changed the way we work in the past 5 years.</p>

<p>{% img center /images/4-ways-docker/docker-whale.jpg &lsquo;4 ways Docker changed the way software engineers work in past half decade&rsquo; &lsquo;4 ways Docker changed the way software engineers work in past half decade&rsquo; %}</p>

<!-- more -->


<h2>TLDR;</h2>

<blockquote><p>With Docker, you ship the whole stack not only your code. Allocate minimum required resources to containers then scale them horizontally. With containers security generally already comes baked In. With Docker and Kubernetes you can get zero downtime and faster deployments leading to business profit.</p></blockquote>

<h2>Changed the ways</h2>

<p>If you want to go to the technical details of what is a container and why to use docker Google it :).</p>

<blockquote><p>Docker has also partially deprecated many of the configuration management tools.</p></blockquote>

<p>This post is about how Docker has changed the way we work after its release in March 2013. Below are some reasons that helped advance our way of working:</p>

<h3>Ship the whole stack, not just code</h3>

<p>With containers and Docker in specific, you always ship the whole stack in each version. The whole image gets rebuilt every time. It includes the precise OS+version, specific version of the language. It also has the dependencies like the framework and other libraries (versions depend on how you handle it). It also includes the code you have written and this results in a significant advantage. The advantage is, if it built correctly on your machine, it will potentially build on the server too. As soon as it runs it is the exact same environment on dev, staging, testing and even on production.</p>

<blockquote><p>It happens because you didn&rsquo;t shop only the code, you shipped your code + vendor code + specific language version + precise OS version too.</p></blockquote>

<h3>Allocate only needed resources to the application and scale horizontally</h3>

<p>With each Docker container, you can be specific about how much resources you want to allocate to that particular container. Using software like Kubernetes it becomes so much easier to scale your application. Under high load, the no. of containers can expand and with less load, it can shrink too. So with this mechanism, each container (or pod for Kubernetes) can be allocated the minimum resources and scaled horizontally as per need.</p>

<blockquote><p>For example, a simple Node JS app container/pod can run with like 128 MB memory and 0.25 CPU. As and when load increases run 5 pods in place of 2.</p></blockquote>

<p>This requires the application to be built with horizontal scalability in mind. That basically means storing no data on the file system. Treating containers like cattle, not pet helps scale horizontally. It also makes high availability of application an achievable task.</p>

<h3>Security is baked in</h3>

<p>Using a container, not virtual machine the attack surface is already decreased. Following container security best practices you can already improve your security measures. Of course, if you have holes in the application like SQL injection that is a different story. Still, with smaller and security-focused images like Alpine, it will be easier to get the basics right.</p>

<blockquote><p>Security is always about keeping the attack surface small. With containers and Docker closing more doors become easier.</p></blockquote>

<p>The container should have access to only what it needs. As the file system is temporary for containers it can be a security boon as well as a security auditing issue.</p>

<h3>Deploy faster with zero downtime</h3>

<p>Deploying Docker containers is always about shipping the whole stack. So the chances of one file not syncing or one server not getting the latest changes are not there. As a successful build of the image is always required to deploy it any problems will be found in the build process.</p>

<blockquote><p>With software like Kubernetes and Helm, orchestrating and deploying containers become straightforward. With High Availability (HA) in place using proper load balancing, deployments can be zero downtime.</p></blockquote>

<p>Easier and faster deployment equates to the ability to deploy smaller changes. Smaller changes done well can lead to a better response to market needs quickly. To sum up, use the right tools to deploy your containers in a way to use it for business advantage.</p>

<h2>Conclusion</h2>

<p>The past 5 years have seen rapid adoption of Docker. With tools like Kubernetes deploying and scaling applications has been much effortless than some years ago.</p>

<blockquote><p>Don&rsquo;t worship your virtual machines, use the resources it provides efficiently. Get on the Docker and containers train and reap its benefits.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Use Docker? 3 Reasons From a Development Perspective]]></title>
    <link href="http://geshan.com.np/blog/2018/10/why-use-docker-3-reasons-from-a-development-perspective/"/>
    <updated>2018-10-10T15:29:22+11:00</updated>
    <id>http://geshan.com.np/blog/2018/10/why-use-docker-3-reasons-from-a-development-perspective</id>
    <content type="html"><![CDATA[<p>Docker has been popular in the technology space in the past 5 years is an understatement. It has <a href="https://trends.google.com/trends/explore?date=2013-09-08%202018-10-08&amp;q=%2Fm%2F0wkcjgj">exploded</a> in usage and popularity in half a decade. Containers have taken us by storm. Newer applications without containerization feel like it is missing something. Docker has stood out to be the king in the container arena. This post details the reasons to use Docker for your development environment.</p>

<p>{% img center /images/why-docker/whale.jpg &lsquo;Why use docker? 3 reasons from a development perspective&rsquo; &lsquo;Why use docker? 3 reasons from a development perspective&rsquo; %}</p>

<!-- more -->


<h2>TLDR;</h2>

<blockquote><p>Docker is super useful for development environment because if it runs on your machine, it runs anywhere. It runs on your friend&rsquo;s machine, on staging and also on production. When a new team member starts, s/he runs 3 commands and the app(s) are running. The new team member can be productive from day 1. Finally, a new version of PHP or MYSQL is coming. You can test your app easily with Docker and make it run in the old version with no issues.</p></blockquote>

<h2>Docker Docker Docker</h2>

<p>You can <a href="https://runnable.com/docker/why-use-docker">read</a> all you want about Virtual Machines (VMs) vs Containers. And there is a list of reasons to use Docker in the <a href="https://www.airpair.com/docker/posts/8-proven-real-world-ways-to-use-docker">real-world</a>. This piece discusses why to use Docker for development. If you want to go hands read about using <a href="https://geshan.com.np/blog/2017/05/how-to-use-docker-compose-with-virtual-hosts-and-services-like-db-for-dev-environment/">docker and docker compose</a> for your development environment.</p>

<p>Docker has many advantages but the most important one is the container analogy. That you don&rsquo;t only ship your code but ship the whole OS and all related layers with each deployment in a standard way. It is a complete package containing the right version of OS, the desired version of the language, any external dependencies of your application and your application code. That too in a lightweight, isolated and resource controllable way. This is where docker blows away the VMs.</p>

<p>{% img center /images/why-docker/ship.jpg &lsquo;Why use docker? 3 reasons from a development perspective&rsquo; &lsquo;Why use docker? 3 reasons from a development perspective&rsquo; %}</p>

<h2>Reasons to use Docker for the development environment</h2>

<p>If you have read this far, now let&rsquo;s dive into the reasons you would want to use Docker for your development environment:</p>

<h3>1. Runs on my machine = runs anywhere</h3>

<p>If you have correctly dockerized your app and it runs without problems on your machine, 99% of the times it will run smoothly anywhere. By anywhere it means on your friend&rsquo;s machine, on the staging environment and production too. Given all of them have docker installed and configured correctly your app will run. Using docker also makes the application code cloud provider agnostic. Your application can potentially run on AWS or GCP or Azure without issues.</p>

<h3>2. New team member can be productive from day 1</h3>

<p>Think of this, a new team member joins then s/he spends more than a day to set up the machine with the right OS. Setup the language(s) used in the company add database(s) on top of it. 2-3 days is wasted on just getting the environment setup correctly. Enter docker + docker-compose, the new joiner sets up the OS. Installs docker then runs 3-5 commands, grabs some coffee and magic: your apps(s) are running. The new joiner can contribute with the working code on day 1. Think of all the cost a company can save with this approach. A streamlined docker implementation makes it a reality.</p>

<h3>3. Test app&rsquo;s compatibility with the newer version of language/database</h3>

<p>Picture this, a new version of the language you use just released. Like you were using PHP 5.6 and 7.0 has come out. You don&rsquo;t know how much work will be needed to make your application compatible with the new version of the language. Use docker here, you just need to run two different docker containers one running the current version and another running the newer version. You can even test the app side by side to measure performance. This can apply for any programming language.</p>

<p>The same technique can be used to say test MYSQL version 5.7 and 8.0. You might think there are tools like NVM (Node version manager) or RVM (Ruby version manager) but things like that don&rsquo;t exist for each language. Also, you can just use docker than overloading your local machine.</p>

<h2>Conclusion</h2>

<p>Docker is a boon to both software engineers and DevOps engineers. It makes releasing software much easier as the whole stack is shipped not only the code. Still, to move your production to Docker many things need to be considered. Things like container builder (for instance <a href="https://cloud.google.com/cloud-build/docs/">Google cloud build</a>), container orchestration (like <a href="https://kubernetes.io/">Kubernetes</a>). So before jumping to the container on staging/production be convinced of its benefits on the local development environment. I hope you exploit Docker to extract the most benefit out of it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't Just Learn a New Language/framework, Implement It as a Running Open Source Project]]></title>
    <link href="http://geshan.com.np/blog/2018/10/dont-just-learn-a-new-language-slash-framework/"/>
    <updated>2018-10-08T15:27:26+11:00</updated>
    <id>http://geshan.com.np/blog/2018/10/dont-just-learn-a-new-language-slash-framework</id>
    <content type="html"><![CDATA[<p>“For the things we have to learn before we can do them, we learn by doing them.” ― Aristotle, The Nicomachean Ethics. Imagine you already read 3 books about cycling. Then someone gave you a cycle and asked to ride it, will you be able to ride it? The simple answer is &ldquo;No&rdquo;. It is not about how much have you read about cycling or how many videos did you watch about it. It is about getting on a cycle, balancing on it, learning the feet, hands and eye co-ordination. Same goes for learning a new tech skill, a new language or framework.</p>

<p>{% img center /images/language-framework-learn/cycle.jpg &lsquo;Dont just learn a new language framework, implement it as a running open source project&rsquo; &lsquo;Dont just learn a new language framework, implement it as a running open source project&rsquo; %}</p>

<!-- more -->


<p>Now if you think how will I do this new project I don&rsquo;t even know language &lsquo;X&rsquo; or framework &lsquo;Y&rsquo; stop complaining. Maybe you are a new starter in tech or coding but you need to know how to learn new things. The best way to learn something new is by doing it. This post will focus on getting some common things right. It will help you get from I want to learn &lsquo;X&rsquo; to I have a project running in &lsquo;X&rsquo;, so follow on. If you are convinced about doing a project to learn something new, open source it. Github is the de facto service to host your open source projects. Then you can leverage lots of services for free. This post will be equally useful for coding new starters as well as experienced software engineers.</p>

<h2>TLDR;</h2>

<blockquote><p>Write a project to learn that language/framework, open source it then leverage services for free. Don&rsquo;t just watch courses, read the docs and then find solutions. Learn by doing. Use git and implement docker in your project. Code correctly add a code quality check service to be aware of the best practices, deploy your project to get a working URL for it.</p></blockquote>

<p>{% img center /images/language-framework-learn/lang-framework-learn.jpg &lsquo;Dont just learn a new language framework, implement it as a running open source project&rsquo; &lsquo;Dont just learn a new language framework, implement it as a running open source project&rsquo; %}</p>

<h2>Don&rsquo;t just watch courses, read the docs and find solutions</h2>

<p>Nowadays, there are a plethora of choices to learn new things. Still, video courses are one of the most popular media. You can learn something new on <a href="https://www.udemy.com">Udemy</a>, <a href="https://www.pluralsight.com/">Pluralsight</a> or even <a href="https://youtube.com">Youtube</a>. Until you learn by doing, watching the videos is only going to help to a certain level. It is better for you to go through the official documentation. For instance, reading the React JS docs is better than only going through a React JS course. You find out the creators&#8217; perspective. The reason behind creating another Javascript framework/library helping you find proper solutions.</p>

<h2>Learn Git to collaborate</h2>

<p>&ldquo;No man is an island&rdquo;, especially in tech you generally don&rsquo;t work alone. You are part of a team. So even when learning something new try to find someone who you can collaborate with. Git is immensely <a href="https://trends.google.com/trends/explore?q=git,svn,mercurial,bazaar">popular</a> compared to any of its competition. It is beneficial when there is more than 1 person writing code for a project. You should learn git by doing, check the Github <a href="https://try.github.io/">tutorial</a>. I would highly recommend the learn by doing section. After you push it to Github anyone can potentially contribute to it.</p>

<h2>Implement docker, get over works on my machine syndrome</h2>

<p>In 2018, if you want to make your application more accessible, use <a href="https://www.docker.com/">Docker</a>. This will also help a lot in increasing contribution for your open source project. Running your project locally with docker compose will be like executing 2 commands. Docker has many advantages. For a beginner, it is a way to make sure your app runs the same way on your machine, your friend&rsquo;s machine. It will also be the same on the server you deploy your app to. As long as it runs on Docker well, you can rest assured it will run without issues on any environment.</p>

<h2>Add code quality check</h2>

<p>Just making it work should not be your priority. Writing quality should also be in your priority. Add code quality checks for the open source project you created for learning. Depending on the language/framework you could choose any service. I would highly recommend <a href="https://codeclimate.com/quality/">Code Climate</a>. Code Climate supports a wide array of languages from Javascript to PHP and from Java/Kotlin to Swift for mobile developers. With the new <a href="https://codeclimate.com/browser-extension/">browser plugin</a>, you get insights about your code in a Github pull request screen. You just connect it once to your Github repo and start seeing your code quality report. You can then better your code quality too. You can have a look at this <a href="https://codeclimate.com/github/geshan/currency-api/src/exchangeRates.js/source">example</a>.</p>

<h2>Deploy your project</h2>

<p>Now you are writing a new project to learn your favorite &lsquo;X&rsquo; or &lsquo;Y&rsquo;. You have written some parts of it, you are collaborating with Git and have the code open source on Github. You have Docker in place and code quality checks run on each push, great! But you can&rsquo;t show it to your friend who is living in a different city/country right? Wrong!</p>

<p>You can use different services to deploy your web application. With a URL you can show it to your friend, a recruiter or anyone who knows the URL. You can deploy it for free to services like <a href="https://www.heroku.com">Heroku</a> or <a href="https://zeit.co/now">Zeit Now</a>.
If you have Dockerized your open source app I would recommend Zeit Now. With the recent <a href="https://zeit.co/github">Github integration</a>, Zeit Now will give a new URL to each pull request. This makes testing a breeze. You can check an example on a demo <a href="https://github.com/geshan/currency-api/pull/9">currency converter API</a> app I wrote.</p>

<h2>Conclusion</h2>

<p>To conclude, learning by doing is the best way to learn a new thing. Your aim should be to not only make it work but do it following the best practices. That is where code quality comes into play. If you can add automated tests and continuous integration it will be icing on the cake for a starter. Wish you all the best for learning by doing!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Use Docker Compose With Virtual Hosts and Shared Services (Like Db) for Dev Environment]]></title>
    <link href="http://geshan.com.np/blog/2017/05/how-to-use-docker-compose-with-virtual-hosts-and-services-like-db-for-dev-environment/"/>
    <updated>2017-05-25T00:53:04+10:00</updated>
    <id>http://geshan.com.np/blog/2017/05/how-to-use-docker-compose-with-virtual-hosts-and-services-like-db-for-dev-environment</id>
    <content type="html"><![CDATA[<p>Docker as been immensely popular in the past years. If you are not using docker at least in your dev environment in 2017.
You are surely missing out on some great advantages. Your new software engineer should start writing production-ready code
in a matter of hours not days. All thanks to docker.  Along the same lines, this post will cover how you can set up
docker for your dev environment with least friction and maximum productivity. It is an opinionated post. We migrated to this <code>external_links</code>
<a href="https://docs.docker.com/compose/compose-file/#externallinks">approach</a> so that we could run multiple projects/microservices that use the same db/services shared among them.</p>

<p>{% img center /images/docker-compose-vhost/docker-compose-vhost.jpg &lsquo;Docker compose with vhost and shared services&rsquo; &lsquo;Docker compose with vhost and shared services&rsquo; %}</p>

<!-- more -->


<h2>Context</h2>

<ul>
<li>This tutorial is generally agnostic of docker and docker-compose versions (I am using docker compose 1 syntax). I assume you have docker and docker-compose installed and know about them.</li>
<li>It uses external images like Nginx proxy for virtual host per project. Mysql db as shared external service. It could also have been mongo or redis or even rabbit mq. The main point is to use it as <code>external_link</code> in the docker compose file, so that it can be shared among projects.</li>
<li>It uses a demo app which emulates the page visit/hit counter popular decades back with a <a href="https://github.com/geshan/counter/blob/master/index.js">~30 liner Nodejs app</a> and Mysql db.</li>
<li>I would like to keep the description as concise as possible and in points to make it simple and clear. You should read the code of <a href="https://github.com/geshan/counter">sample counter project</a> and sample mysql container&rsquo;s <a href="https://github.com/geshan/sample-mysql/blob/master/docker-compose.yml">docker-compose.yml</a> well.</li>
<li>The goal is to grasp the concepts well and apply it to your current project. For example, you could start with replacing your local mysql install with a docker container.</li>
</ul>


<h2>Problems to solve</h2>

<ol>
<li>After I use docker and docker compose, the web server (nginx/apache etc) of project A takes up port 80 and I can&rsquo;t run project B on port 80 or have a virtual host for both projects.</li>
<li>When I use my db (mysql/postgres) as a service in my docker compose for project A, It is cumbersome to use the same db for another project as its coupled with project A.</li>
<li>I just want to run my mysql database, import some data and run some queries. I don&rsquo;t want to run my app for now.</li>
</ol>


<h2>Solution goals</h2>

<ol>
<li>To make services like db etc independent of projects and shared among projects similar to having a local install of mysql with multiple databases.</li>
<li>Multiple projects should be able to run in parallel and each of them will have their own virtual host for easy accessibility.</li>
</ol>


<h2>Steps</h2>

<ol>
<li>Run the Nginx proxy to enable virtual hosts with <code>$ docker run -d -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy</code></li>
<li>Add <code>127.0.0.1 counter.local.dev</code> to your hosts file (on unix based system it is <code>/etc/hosts</code> file)</li>
<li>Create an empty folder db in your home (<code>~/db</code>), to save your mysql data</li>
<li>Clone mysql repo from <a href="https://github.com/geshan/sample-mysql">here</a> maybe at <code>~/projects/mysql</code></li>
<li>In <code>~/projects/mysql</code> run docker-compose up to run mysql, it will create <a href="https://github.com/geshan/sample-mysql/blob/master/init-dump/counter.sql">counter db, counts table with one row</a>.</li>
<li>Clone the sample counter app from <a href="https://github.com/geshan/counter">here</a> to maybe <code>~/projects/counter</code>.</li>
<li>In <code>~/projects/counter</code> run <code>docker-compose up</code></li>
<li>Then go to <code>http://counter.local.dev</code> on your browser you should see <code>Page visited 1 times</code>, refresh it, it should say <code>Page visited 2 times</code></li>
</ol>


<p>{% img center /images/docker-compose-vhost/page-visited.png &lsquo;All working you should see this&rsquo; &lsquo;All working you should see this&rsquo; %}</p>

<p>Virtual host has been possible in above setup as we ran the nginx proxy and configured <code>VIRTUAL_HOST</code> and <code>VIRTUAL_PORT</code> parameters correctly
in the docker-compose.yml of the sample counter project. Mysql was already running before the project even started to run and it was <code>external_links</code>,
the IP of the mysql container was automatically added to the <code>/etc/hosts</code> of the counter project container which enabled us to use the host for mysql db
as <a href="https://github.com/geshan/counter/blob/master/index.js#L4">mysql</a> in the connection config we passed to the mysql library.</p>

<p>Steps for running dependent services like nginx proxy, mysql can surely be automated for speed and efficiency.</p>

<h2>Takeaways</h2>

<ol>
<li>You can plan a step by step migration like first get your db/queue migrated from local install to docker then the app.</li>
<li>Use <code>external_links</code> for all the services like db/queue/redis/solr anything that needs to be shared among projects.</li>
<li>Use <a href="https://github.com/jwilder/nginx-proxy">nginx proxy</a> to enable virtual host per project with two simple env variables <code>VIRTUAL_HOST</code> and <code>VIRTUAL_PORT</code> in the project&rsquo;s <a href="https://github.com/geshan/counter/blob/master/docker-compose.yml#L8-L9">docker-compose</a> file. <code>VIRTUAL_PORT</code> is 8080 because application is <a href="https://github.com/geshan/counter/blob/master/index.js#L27">running</a> on port 8080 and same port is exposed from the <a href="https://github.com/geshan/counter/blob/master/Dockerfile#L10">dockerfile</a>.</li>
<li>Run all your dependencies before hand and then run <code>docker-compose up</code> on your project(s). Dependencies can be run with <code>docker-compose up -d</code> to put it in the background. You can use <code>docker-compose -f logs</code> to follow logs and check if the service is running fine.</li>
<li>In this way, you can run multiple projects sharing the same db instance and each project can have its own virtual host.</li>
</ol>


<blockquote><p>Hope you found this helpful. For more clarity, please read the <a href="https://github.com/geshan/counter/blob/master/Dockerfile">Dockerfile</a>, <a href="https://github.com/geshan/counter/blob/master/docker-compose.yml">docker-compose.yml</a> and <a href="https://github.com/geshan/counter/blob/master/index.js">index.js</a> of the sample counter project thoroughly.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With Laravel, MariaDB (MySQL) and Docker, Docker Compose]]></title>
    <link href="http://geshan.com.np/blog/2015/10/getting-started-with-laravel-mariadb-mysql-docker/"/>
    <updated>2015-10-24T18:49:48+11:00</updated>
    <id>http://geshan.com.np/blog/2015/10/getting-started-with-laravel-mariadb-mysql-docker</id>
    <content type="html"><![CDATA[<p>&ldquo;How do I get new team members contributing code to the project in a matter of minutes/hours not days?&rdquo; is a common question heard in development teams. There are some ways to do, in my opinion <a href="http://docker.com">docker</a> is one of the best.</p>

<p>Docker enables using same software stack in development, staging and production. You don&rsquo;t need to worry about the version of PHP, MYSQL or any other dependency with Docker. This post will be about Laravel and MariaDB (MySQL) with Docker for local development. It will also feature use of docker-compose. We will use PHP 5.6 and MariaDB 10.1 with Laravel 5.1.</p>

<p>{% img center /images/laravel-mysql-docker/laravel-mysql-docker.png &lsquo;Getting started with Laravel, MariaDB (MySQL) and docker, docker compose&rsquo; &lsquo;Getting started with Laravel, MariaDB (MySQL) and docker, docker compose&rsquo; %}</p>

<!-- more -->


<h2>Prerequisites</h2>

<ul>
<li>You are aware about docker and is basic usage. If you are new to docker check an <a href="http://bit.ly/1LsQ4X6">introduction screen-cast</a>) or read this <a href="http://bit.ly/1FVjL0k">Docker for PHP Developers</a> post</li>
<li>You know about docker volumes and linking containers with docker-compose.</li>
<li>You are running Laravel 5.x on your local machine with some PHP and MySQL setup. The setup can be local LEMP stack or XAMPP or something similar.</li>
<li>You have docker and <a href="https://docs.docker.com/compose/install/">docker compose</a> installed on your machine</li>
<li>You have stopped your Apache/Nginx service and MYSQL service. It will free port 80 and 3306. If
you are using vagrant and homestead then you can run Laravel without starting it.</li>
</ul>


<h2>Software Versions used</h2>

<p>I am running this example on Ubuntu 14.04.2 LTS.</p>

<ul>
<li>Docker : 1.7.1 (<a href="https://docs.docker.com/installation/">Installation Instructions</a>)</li>
<li>Docker compose : 1.3.1 (<a href="https://docs.docker.com/compose/install/">Installation Instructions</a>)</li>
</ul>


<h2>Why use docker?</h2>

<p>The reasons to use docker are simiar to <a href="http://geshan.com.np/blog/2014/07/getting-started-with-php-lemp-on-vagrant/">vagrant</a>. There are some more compelling reasons to use docker and docker compose, some of them are:</p>

<h3>Quick setup of development environment</h3>

<p>The developer/software engineer does not need to know which version of PHP or MySQL is in use. All s/he needs to do is <code>docker-compose up</code> and wait for the images to download (around 230 MB). After that add a entry to the /etc/hostsfile like <code>echo 127.0.0.1 project-name.dev &gt;&gt; /etc/hosts</code>. Then the project runs at <code>http://project-name.dev</code> on the browser.</p>

<h3>No need to install software on local machine</h3>

<p>With docker containers applications are self sufficient. There is no need to upgrade to the latest version of PHP or MySQL. The right version is already packaged inside the dockerfile and also in the container. There is no problem of one developer running PHP 5.5 and another one running PHP 5.6. All developers run the same container. You can install PHP to run composer and other scripts.</p>

<h3>Same software stack in all environments</h3>

<p>Same docker container can be deployed to staging or production environments. The same software stack with correct software versions is used across environments. For example the problem of one developer using MySQL 5.6 and staging running MySQL 5.5 ends.</p>

<p>A <a href="https://github.com/jwilder/nginx-proxy">NGINX proxy</a> can be used to make the virtual hosts dynamic. This post is about keeping things simple.</p>

<h2>Steps to running Laravel 5.x with MariaDB (MySQL) with docker</h2>

<p>For this example I will use docker images with <a href="https://hub.docker.com/_/alpine/">Alpine Linux</a> base images. Alpine image is just 5 MB which makes it the best candidate for docker base images. We will use PHP version 5.6 and MariaDB version 10.1. MariaDB is a drop in replacement of MySQL and for Alpine only MariaDb is available. The example git repo for this blog post is available on <a href="https://github.com/geshan/laravel-mysql-docker">github</a>.</p>

<h3>Install Laravel 5.1 on local machine</h3>

<p>Run the following command:</p>

<pre><code>composer create-project laravel/laravel --prefer-dist laravel-mysql-docker
</code></pre>

<p>I installed it on <code>~/Projects/misc/laravel-mysql-docker</code></p>

<h3>Add larael-docker.dev to /etc/hosts</h3>

<p>While it is downloading Laravel add <code>127.0.0.1 larave-docker.dev</code> to your <code>/etc/hosts</code> file. It can be
done quickly with the command below:</p>

<pre><code>sudo echo '120.0.0.1 laravel-docker.dev' &gt;&gt; /etc/hosts
</code></pre>

<h3>Setup docker images with docker-compose</h3>

<p>We will use <a href="https://github.com/dydx/alpine-nginx-php-mariadb">dydx/alpine-nginx-php-mariadb</a> and modify it to suit our needs. It is a docker replacement for homestead. Both docker images are based on Alpine Linux which makes it small. Create the following <code>docker-compose.yml</code> file on root of the project:</p>

<pre><code>front:
  image: dydx/alpine-nginx-phpfpm
  ports:
    - "80:80"
  volumes:
    - .:/var/www
    - docker/nginx/sites-enabled:/etc/nginx/sites-enabled
  links:
    - mysql:mysql

mysql:
  image: dydx/alpine-mariadb
  ports:
    - "3306:3306"
  volumes:
    - docker/db/data:/var/lib/mysql
</code></pre>

<ul>
<li>We are using dydx/alpine-nginx-phpfpm image named as front, it has PHP Nginx 1.8 and PHP-FPM.</li>
<li>It uses supervisor to keep nginx and PHP-FPM running.</li>
<li>We copy the all the files in current folder inside docker at <code>/var/www</code> to execute it.</li>
<li>Other volumes are there to override the sites-enabled with virtual host and supervisor config to fix an error.</li>
<li>The second definition is MySQL for which the data is saved in ./docker/db/data folder.</li>
<li>The front container links the MySQL (MariaDB) container with the name <code>mysql</code></li>
</ul>


<h3>Create needed folders</h3>

<p>In project root create the following folders:</p>

<pre><code>./docker
./docker/db
./docker/nginx
./docker/nginx/sites-enabled
</code></pre>

<p>All MYSQL/MariaDB data that would generally be stored in <code>/var/lib/mysql</code> will be linked as volume from <code>./docker/db</code>.
This is done as docker containers don&rsquo;t have data persistence. This will keep the MySQL data persisted on the host machine which will be reused when the MySQL/MariaDB container is restarted. The folder structure should
be like below:</p>

<p>{% img center /images/laravel-mysql-docker/folder-structure.png &lsquo;Laravel, MariaDB (MySQL) and docker, docker compose folder structure&rsquo; &lsquo;Laravel, MariaDB (MySQL) and docker, docker compose folder structure&rsquo; %}</p>

<h3>Create default sites-enabled</h3>

<p>Create a file named <code>default</code> on <code>./docker/nginx/sites-enabled</code> like below:</p>

<pre><code>server {
  server_name laravel-docker.dev;
  root        /var/www/public;
  index       index.php;

  client_max_body_size 100M;
  fastcgi_read_timeout 1800;

  location / {
    try_files $uri $uri/ /index.php$query_string;
  }

  location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
    expires       max;
    log_not_found off;
    access_log    off;
  }

  location ~ \.php$ {
    try_files     $uri =404;
    include       fastcgi_params;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    fastcgi_pass  127.0.0.1:9000;
  }
}
</code></pre>

<h3>Run Docker compose up</h3>

<p>Now give you are in the project root, you can run <code>docker-compose up</code> to build and run the containers.
Wait for the containers to download. You can do more customization if you create your own image and do a
docker-compose build to build the images.</p>

<p>After you run docker-compose up you will see output like below:</p>

<p>{% img center /images/laravel-mysql-docker/docker-compose-up.png &lsquo;Laravel, MariaDB (MySQL) and docker, docker compose up output&rsquo; &lsquo;Laravel, MariaDB (MySQL) and docker, docker compose up output&rsquo; %}</p>

<h3>Fix permissions</h3>

<p>The containers are up still as the cache and logs are not writable it will hit a 500 Internal server
error. To fix this use the following command to relax the file permissions inside the container in a
new console tab.</p>

<pre><code>docker exec -it laravelmysqldocker_front_1 chmod 0777 /var/www/storage -R
</code></pre>

<p>or it can be done locally too with the following command:</p>

<pre><code>chmod 0777 /var/www/storage -R
</code></pre>

<p>If you want to run your artisan commands you can run them inside the front container. Hit the command below:</p>

<pre><code>docker exec -it laravelmysqldocker_front_1 /bin/sh
</code></pre>

<p>You will get the shell of the front container then do <code>cd /var/www</code> and <code>php artisan</code> all your artisan commands are there.</p>

<h3>Access <a href="http://http://laravel-docker.dev">http://http://laravel-docker.dev</a></h3>

<p>You should be able to load Laravel in the browser now navigating to <code>http://laravel-docker.dev</code>. Here you can see the Laravel 5 default page loading.</p>

<h2>MySQL Settings</h2>

<p>You can check if MySQL/MariaDB is running by logging into MySQL locally with:</p>

<pre><code>mysql -uhomestead -psecret homestead
</code></pre>

<p>This will connect to you local port 3306 and you can see that mysql is working. You can even use tools like
MySQL workbench to verify that MySQL is working fine.</p>

<p>From the container when you connect to MySQL the <code>DB_HOST</code> is not localhost anymore it should be <code>mysql</code> (as set in docker-compose.yml file) and you are all set to use MySQL. As an example have a look at the db part of .env file I used:</p>

<pre><code>DB_HOST=mysql
DB_DATABASE=homestead
DB_USERNAME=homestead
DB_PASSWORD=secret
</code></pre>

<p>The easiest way to verify if Laravel is talking to MySQL/MariaDb correctly is just run the following command:</p>

<pre><code>docker exec -it laravelmysqldocker_front_1 /bin/sh

## you will be inside the front container now

cd /var/www/

php artisan migrate
</code></pre>

<p>Then you will see some messages like below:</p>

<pre><code>Migration table created successfully.
Migrated: 2014_10_12_000000_create_users_table
Migrated: 2014_10_12_100000_create_password_resets_table
</code></pre>

<p>Now run the following queries on MySQL/MariaDb via the cli client or some other client like MySQL Workbench.</p>

<pre><code>use homestead;
describe users;
</code></pre>

<p>You will get an output like below:</p>

<p>{% img center /images/laravel-mysql-docker/users-table.png &lsquo;Laravel, MariaDB (MySQL) and docker, docker compose users table&rsquo; &lsquo;Laravel, MariaDB (MySQL) and docker, docker compose users table&rsquo; %}</p>

<h3>Stop docker containers</h3>

<p>You have seen that docker is running from the containers. To stop your containers you should run:</p>

<pre><code>docker-compose stop
</code></pre>

<p>on the project root and it will stop the containers like below:</p>

<p>{% img center /images/laravel-mysql-docker/docker-compose-stop.png &lsquo;Laravel, MariaDB (MySQL) and docker, docker compose stop output&rsquo; &lsquo;Laravel, MariaDB (MySQL) and docker, docker compose stop output&rsquo; %}</p>

<h2>Next Steps</h2>

<p>You can carry on using the docker containers to replace your local Apache/Ngnix and MySQL. You can develop your Laravel applicaiton with ease using docker and docker compose.</p>

<h2>Conclusion</h2>

<blockquote><p>You can use this analogy that containers are cattle and virtual machines (VMs) are pets.</p></blockquote>

<p>Creating, deleting and reconstructing the containers should be easy, fast and seamless than VMs.
If you want to speed up your development flow and help other team members contribute faster to the project
opt for docker and docker-comopse. Happy Dockerizing and coding Laravel + PHP!</p>
]]></content>
  </entry>
  
</feed>
